# ADVENT OF CODE 2023
# WOJCIECH KOÅšNIK-KOWALCZUK
# DAY: 20


import math


# GET DATA
with open("DATA.txt", 'r') as data_file:
    DATA = data_file.read().split('\n')


# testing
example1 = [
    "broadcaster -> a, b, c",
    "%a -> b",
    "%b -> c",
    "%c -> inv",
    "&inv -> a"
]

example2 = [
    "broadcaster -> a",
    "%a -> inv, con",
    "&inv -> b",
    "%b -> con",
    "&con -> output"
]


# UTILITY FUNCTIONS
def data2modules(data, display=False):
    '''
    Converts data to modules and returns them as
    tuple (bradcaster, modules), where modules
    is a dictionary populated as follows:

    flip-flops:
    '_': {'type': '%', 'state': on' (or 'off'), 'out': [_,.. ]}

    conjunctions:
    '_': {'type': '&', 'state': {'module': 'low' (or 'high'),.. }, 'out': [_,.. ]}

    and broadcaster as a list of outputs
    '''
    # bradcaster
    broadcaster = [d for d in data if d.startswith('broadcaster')][0].split(' -> ')[1].split(', ')
    if display: print("Broadcaster outputs:", broadcaster)
    
    # modules
    modules = {}

    # extract modules
    for line in data:
        # extract module name type and output
        module_name, destination_modules = line.split(' -> ')
        destination_modules = destination_modules.split(', ')

        # populate modules:
        # flip-flop
        if module_name[0] == '%':
            modules[module_name[1:]] = {'type': module_name[0], 'state': 'off', 'out': destination_modules} 
        # conjuction
        elif module_name[0] == '&':
            modules[module_name[1:]] = {'type': module_name[0], 'state': {}, 'out': destination_modules}

    # populate conjuctions memories
    for module_name, module in modules.items():
        if module['type'] == '&':
            # loop over modules to find if their outputs mach current conjuction
            for name, value in modules.items():
                # if module(name) has module_name in it's outputs
                if module_name in value['out']:
                    # add it to module_name states
                    modules[module_name]['state'][name] = 'low'

    if display:
        print("Modules:")
        for m in modules.items():
            print(m)
    
    return broadcaster, modules

def execute_module(pulse, modules):
    '''Returns list of pulses generated by executing given pulse' destination module'''
    previous, module, intensity = pulse

    # testing value
    if module == 'output':
        return []

    # find proper module in modules
    for name, value in modules.items():
        if module == name:

            # flip-flop
            if value['type'] == '%':
            
                # if pulse is high
                if intensity == 'high':
                    return []
                
                # if pulse is low
                if value['state'] == 'on':

                    # update modules
                    modules[name]['state'] = 'off'
                    return [(module, d, 'low') for d in value['out']]
                
                #value['state'] == 'off'
                modules[name]['state'] = 'on'
                return [(module, d, 'high') for d in value['out']]
                
            # conjunction
            if value['type'] == '&':
                
                # update modules
                modules[name]['state'][previous] = intensity
                
                # check state
                if all([state == 'high' for state in modules[name]['state'].values()]):
                    return [(module, d, 'low') for d in value['out']]
                
                return [(module, d, 'high') for d in value['out']]
            
    # output for module that was not in the modules list
    return []

def simulate_button_push(data, button_pushes=1, mode=None, display=False, target_pulse=None):
    '''
    Simulates button push (sends pulses through all relevant modules)

    In default mode (final_module=False) returns tuple with number of low and high pulses
    In fil_module=True mode returns number of pushes till low pulse reached module rx

    modes:
    None - returns tuple with number of low and high pulses (for star1() purposes)
    'last conjunction' - returns list of all pulses sent after one button push (for find_last_conjunction_module() purposes)
    'required pushes' - returns number of pushes till target_pulse is reached (for calculate_required_presses() purposes)

    '''
    # initiate variables
    broadcaster, modules = data2modules(data, display)
    current_pulses = []
    pulses_sent = {'low': 0, 'high': 0}
    if mode == 'last conjunction': final_module_return_list = []

    # loop through button pushes
    push=0
    while push != button_pushes if mode != 'required pushes' else True:
        push += 1
        
        # display progress
        if display:
            print()
            print(f"Pulses for {push} button push")

        # initialize pulses
        iteration_pulses = [('broadcaster', out, 'low')for out in broadcaster]
        pulses_sent['low'] += len(iteration_pulses) + 1

        # iterate over pulses until they all fade out
        while iteration_pulses:
            # loop through iteration_pulses
            for pulse in iteration_pulses:

                # check for searched pulse
                if mode == 'required pushes' and pulse[1:] == target_pulse:
                    return push

                current_pulses.extend(execute_module(pulse, modules))

                # display pulses
                if display: print(f"{pulse[0]} -{pulse[2]}-> {pulse[1]}")

            # return pulses for find_last_conjuction_module()
            if mode == 'last conjunction':
                final_module_return_list.extend(current_pulses)

            # count pulses
            for pulse in current_pulses:
                pulses_sent[pulse[2]] += 1

            # reset variables
            iteration_pulses = current_pulses
            current_pulses = []
    

    if mode == 'last conjunction': return final_module_return_list
    return pulses_sent['low'], pulses_sent['high']

def find_last_conjunction_module():
    '''
    Simulates one push of a button remembering all
    sent pulses, than goes through them 
    starting in final module (rx) in reversed order,
    to find last conjunction on the way to rx
    
    Returns name of last conjunction module
    '''
    # simulate single button push and save all pulses
    pulses = simulate_button_push(DATA, mode='last conjunction', target_pulse=('rx', 'low'))

    # find first pulse send to rx module
    rx_pulse = [pulse for pulse in pulses if pulse[1] == 'rx'][0]

    # get modules
    _, modules = data2modules(DATA)

    # find last conjunction module before signal got into rx
    while True:
        if modules[rx_pulse[0]]["type"] == '&':
            return rx_pulse[0]

def calculate_required_presses(conjunction):
    '''
    Returns amount of required presses
    for a given conjunction to propagate low pulse
    '''
    # get modules
    _, modules = data2modules(DATA)

    # get conjunction state
    inputs = list(modules[conjunction]['state'].keys())


    # caluculate presses needed for to set all inputs on
    sub_pushes = []
    for module in inputs:
        x = simulate_button_push(DATA, mode='required pushes', target_pulse=(module, 'low'))
        print(f"({module} => {x}) * ", end='')
        sub_pushes.append(x)

    print("\b\b= ", end='')
    
    # return least common multiple of pushes for all inputs to set in
    return math.lcm(*sub_pushes)


def star1():
    x, y = simulate_button_push(DATA, 1000)
    print("part 1:", x*y)

def star2():
    print("Part 2: ", end='')
    print(calculate_required_presses(find_last_conjunction_module()))

star1()
star2()
